# Binary Exploit 101 (Pwnable)

# Table of content
- [Introduction](#introduction)
- [Computer architecture](#computer-architecture)
    - [Central Processing Unit](#cpu)
    - [Register](#register)
    - [Memory](#memory)
    - [Machine Language](#machine-language)
- [Tools](#tools)
    - [GDB](#gdb)
    - [Pwntools](#pwntools)
    - [IDA](#ida)
- [Buffer Overflow](#buffer-overflow)
- [Off-by-one](#off-by-one)

# Introduction

Prepare before continue:
- A machine with *virtual machine* ([VMware](https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html)(recommended)/[VirtualBox](https://www.virtualbox.org/wiki/Downloads)/[WSL](https://learn.microsoft.com/en-us/windows/wsl/install)/[Hyper V](https://learn.microsoft.com/vi-vn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)) or bare metal running Linux distro (`debian` is recommended)
- Knowledge of `C programming`, `compiler`, and `assembly` language (ASM) 

Computer unit:
- `Binary`: including only 0 and 1 (bit), this is machine language
- `Decimal`: from 0 to 9. Basic number in daily life  
- `Hexadecimal`: same as decimal but including A to F

ASCII table:

Standing for `American Standard Code for Information Interchange`. Below is the `ASCII` character table, including descriptions of the first 32 characters. ASCII was originally designed for use with teletypes, and so the descriptions are somewhat obscure, and their use is frequently not as intended, more details at [here](https://www.asciitable.com/)

---

## Computer architecture

### CPU

`Central Processing Unit` (CPU) load instructions from memory and execute. Instructions are decided to executed by `Instruction pointer` - a register of `CPU`, used for storing next instruction address. 2 noticeable condition:
- What instructions loaded into memory 
- Instruction pointer has value addresses of above instructions

### Register

a fast memory inside CPU, has same length of the structure CPU (32 bit for Intel 32bit). Some kinds of register:
- `General register`: used for calculating, varriable, parameters (`EAX`, `EBX`, `ECX`, and `EDX`)
- `String handling register`: string actions including copy string or get string length (`EDI`, and `ESI` )
- `Stack register`: managing data stack (`EBP`, and `ESP`)
- `Special register`: including `EIP` (Instruction pointer), and `EFLAGS` contains `1 bit flag`: sign flag, carry flag, zero flag, etc. 
- `Partion register`: managing size of memory (`DS`, `ES`, and `CS`)

### Memory

`Memory` and `Linear address`:
- Using `RAM` to get address of 2 other registers, so computer can get more space with `swap partition`
- `Data bus` and `Address bus` used for transmiting 32-bit data to `CPU` every times
-  `Endianness` is the order or sequence of bytes of a word of digital data in computer memory. `Little edian` is an order in which the "little end" (least significant value in the sequence) is stored first, help `CPU` know how to get specific bit in 32-bit data

![Little edian](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSZtgGIgnQ1DJZgGn2xsd-Gm86kHKRi91k7QA&usqp=CAU)

### Machine language

Some definitions:

- `Instructions` are what CPU can do
- `Machine code` is code which is ready to be executed by machine processor
- `Opcode` is code to be executed by an interpreter
- `Assembly language` often referred to simply as Assembly and commonly abbreviated as ASM or asm, is any low-level programming

---

## Tools

Some useful tools to get started

### GDB

Using `GDB` with [peda](https://github.com/0xKira/peda) to `gdb-peda` - useful to debug binary file. Some commands to get started:
- `checksec`: various security options of binary
    - `CANARY`: protect stack (can overflow if it is disabled)
    - `FORTIFY`: the compiler will try to intelligently read the code it is compiling / building if it is enabled
    - `NX`: can excute shellcode inside program if it is disabled
    - `PIE`: contain address in binary being not change if it is disabled
    - `RELRO`: Global Offset Table (and Procedure Linkage Table) are marked read-only too in the `Full RELRO`
- `pdis main`: view inside main function
- `start`: run header of binary, list some information of registers, code, etc.
- `vmmap`: get virtual mapping address ranges of section(s) in debugged process
- `stack <number>`: get more `<number>` stacks to view
- `x/ <address>`: get value from `<address>`
- `x/<number> <address>`: get `<number>` value started from `<address>`
- `x/<number>i <address>`: get `<number>` value started from `<address>` and print command in assembly language
- `b* <address>`: set breakpoint at `<address>`, use `c`/`continue` to continue program til breakpoint after start program, use `n`/`next` to execute next command
- `r`/`run`: run program from beginning

### Pwntools

Popular tools for python, get details at [here](https://docs.pwntools.com/en/stable/). Get started with `pip install pwntools`. Some commands to get started

```python
    from pwn import *
    r.process("./file") # load target file tto run local
    gdb.attach

    r.remote("123.123.123.123",123) # connect to server with ip and port

    payload = "this is payload"

    # use to send payload
    r.sendline(payload)
    r.sendlineafter("abc",payload)

    # do until receive needed data
    r.recv()
    r.recvuntil("abc")

    r.interactive() # active shell

```

### IDA

Useful tools to disassembler file, find more [here](https://hex-rays.com/) 

---

## Buffer Overflow

Happen when input is too long for limitation of memory. 3 points to take advantage of buffer overflow:
- `Key data` should be behide (at the right side) `Injected data` which can be buffer overflow
- `Injected data` must overflow to `key data` 
- Modified `Key data` must have meaning to execute program

---

## Off-by-one

Happen by logic in code

Example get from [here](/code/OffByOne.cpp) and run binary file with [this](/binary/OffByOne). In this case, we need run `win()` function in code. It has input data from command `scanf("%64s", your_try);` and `scanf` is one of the dangerous functions

Run program with `gdb-peda` with command `start`. Using `pdis main` to view main of program then set breakpoint at `strncmp` to see what happen. Next, type something into program after using `r` to run program.
- If input below 64 characters: 
![first](https://i.ibb.co/PxstSBN/Screenshot-20230130-013408.png)
- If input above 64 characters (66):
![second](https://i.ibb.co/yYgv9tf/Screenshot-20230130-015356.png)

It seems when input is above 64 characters, it changes value of flag `0xa796d6d7564`to `0xxa796d6d7500`, simply last `64` become `00` or NULL so that value of variable flag is NULL now. The reason why can be seen from manual of `scanf` with option string:

`
       Matches a sequence of non-white-space characters; the next pointer must be a pointer to the initial element of a character array that is long enough to hold the input sequence and the terminating null byte ('\0'), which is added automatically.  The input string stops at white space or at the maximum field width, whichever occurs first
`

Method to exploit including:
- type a above 64 string to make variable flag become NULL
- condition will compare 2 NULL string 

Using `pwntools` to exploit

```python
    from pwn import *
    r = process("./chall")
    payload = "\x00"*64 # create 64 byte null string
    r.sendline(payload)
    r.interactive()
```





